---
title: 힙 정렬 (Heap Sort)
author: Jay Jo
date: 2023-11-19 00:00:00 +09:00
categories: [Algorithms]
tags: [algorithms]
image: /assets/img/posts/heap-sort.png
---

- [힙정렬 (Heap Sort)](#힙정렬-heap-sort)
- [힙(HEAP) 정렬의 역사](#힙heap-정렬의-역사)
- [개발 배경](#개발-배경)
- [힙(HEAP) 정렬의 기본 개념](#힙heap-정렬의-기본-개념)
- [정렬 과정](#정렬-과정)
- [최소 힙(Min Heap), 최대 힙(Max Heap), 일반 이진 트리 (Binary Tree)](#최소-힙min-heap-최대-힙max-heap-일반-이진-트리-binary-tree)
- [비-리프 노드(Non-leaf Node)와 리프 노드(Leaf Node)](#비-리프-노드non-leaf-node와-리프-노드leaf-node)
- [힙(Heap) 정렬 알고리즘 예시 [최대 힙 구축]](#힙heap-정렬-알고리즘-예시-최대-힙-구축)


### 힙(HEAP) 정렬의 역사

J. W. J. Williams에 의해 1964년에 처음으로 개발된 힙 정렬은, 영국 출신의 수학자이자 프로그래머인 Williams에 의해 개발되었습니다. 그는 런던 대학교 킹스 칼리지에서 수학 학사 학위를 받은 후 캐나다로 이주하여 통신 분야에서 연구와 개발 활동을 펼쳤습니다.

### 개발 배경

1. **효율성 향상**: Williams는 기존의 정렬 알고리즘들이 큰 데이터 세트에 대해 비효율적이거나 시간이 많이 걸린다는 점에 주목했습니다. 힙 정렬은 O(n log n)의 시간 복잡도를 가지며, 이는 평균적이고 최악의 경우에서도 우수한 성능을 제공합니다.
2. **메모리 최적화**: 초기 컴퓨터 시스템은 메모리 리소스가 제한적이었습니다. 힙 정렬은 추가적인 메모리 할당 없이 정렬을 수행할 수 있는 in-place 알고리즘으로, 메모리 효율성을 높일 필요가 있었습니다.
3. **범용성과 실용성**: Williams는 다양한 유형의 데이터와 다양한 컴퓨팅 환경에서 적용할 수 있는 범용적이고 실용적인 정렬 방법을 개발하고자 했습니다.

논문: Williams, J. W. J. (1964), “Algorithm 232 - Heapsort”, 《Communications of the ACM》 7 (6): 347–348, doi:10.1145/512274.512284

### 힙(HEAP) 정렬의 기본 개념

힙의 정의: 힙은 완전 이진 트리로서, 각 노드의 값이 자식 노드의 값보다 크거나(최대 힙) 작거나(최소 힙) 하는 조건을 만족합니다.
힙 구축: 정렬할 배열을 최대 힙 또는 최소 힙으로 구성합니다. 이 과정에서 모든 Non-leaf Node 에 대해 하향식 힙 조정(heapify) 작업을 수행합니다. 최대 힙을 사용하면 배열의 가장 큰 요소가 **힙의 루트**에 위치하게 됩니다.

### 정렬 과정

1. n개의 노드에 대한 완전 이진 트리를 구성한다. 이때 루트 노드부터 부모노드, 왼쪽 자식노드, 오른쪽 자식노드 순으로 구성한다.
2. 최대 힙을 구성한다. 최대 힙이란 부모노드가 자식노드보다 큰 트리를 말하는데, 단말 노드를 자식노드로 가진 부모노드부터 구성하며 아래부터 루트까지 올라오며 순차적으로 만들어 갈 수 있다.
3. 가장 큰 수(루트에 위치)를 가장 작은 수와 교환한다.
4. 2와 3을 반복한다.

### 최소 힙(Min Heap), 최대 힙(Max Heap), 일반 이진 트리 (Binary Tree)

| 특성 | 최소 힙(Min Heap) | 최대 힙(Max Heap) | 이진 트리(Binary Tree) |
|------|------------------|------------------|----------------------|
| **정의** | 각 부모 노드의 값이 자식 노드의 값보다 작거나 같음 | 각 부모 노드의 값이 자식 노드의 값보다 크거나 같음 | 부모-자식 관계를 가진 노드들의 계층적 구조 |
| **특징** | 힙 내에서 가장 작은 값이 루트에 위치 | 힙 내에서 가장 큰 값이 루트에 위치 | 특정한 순서 규칙이 없음 |
| **구조** | 완전 이진 트리 구조 | 완전 이진 트리 구조 | 이진 트리 구조 (완전할 필요 없음) |
| **삽입/삭제 복잡도** | O(log n) | O(log n) | 평균 O(log n), 최악의 경우 O(n) |
| **사용 목적** | 최솟값에 빠르게 접근, 우선순위 큐 구현 등 | 최댓값에 빠르게 접근, 힙 정렬 구현 등 | 데이터 저장, 검색, 이진 검색 트리 등 |
| **순서 유지** | 순서 유지되지 않음 | 순서 유지되지 않음 | 순서 유지될 수 있음 (이진 검색 트리의 경우) |

### 비-리프 노드(Non-leaf Node)와 리프 노드(Leaf Node)

| 특성 | 비-리프 노드(Non-leaf Node) | 리프 노드(Leaf Node) |
|------|---------------------------|---------------------|
| **자식 노드** | 하나 이상의 자식 노드를 가짐 | 자식 노드가 없음 |
| **트리 내 위치** | 트리의 루트 또는 중간 계층에 위치 | 트리의 가장 바깥쪽, 말단에 위치 |
| **역할** | 트리 구조의 지지와 데이터 전달 역할 | 트리의 데이터 저장의 최종 지점 |
| **예시** | 이진 트리에서 부모 노드로써 자식 노드를 가지는 노드 | 이진 트리에서 자식이 없는 마지막 노드 |
| **특징** | 트리의 동적 조작(삽입, 삭제 등)에 중요한 역할 수행 | 트리의 구조 및 크기 변경에 직접적인 영향을 미치지 않음 |

### 힙(Heap) 정렬 알고리즘 예시 [최대 힙 구축]

힙 정렬 과정은 크게 두 단계로 나뉩니다: 힙 구축 단계와 정렬 단계
1. **힙 구축 단계 (Build Heap Phase)**: 이 단계에서는 주어진 배열을 힙 구조로 변환합니다. 최대 힙을 구축하기 위해 각 Non-leaf Node 에 대해 하향식 힙 조정(heapify) 과정을 수행합니다.
   - 초기 배열: `{15, 22, 13, 27, 12, 10, 20, 25, 30, 18}`
   - 힙 구축 과정:
     - Non-leaf Node 부터 힙 조정을 시작합니다. 배열의 중간부터 시작하면 됩니다.
     - 배열의 중간 인덱스는 배열 길이의 절반보다 하나 작은 위치입니다. 이 경우, 배열 길이가 10이므로, 중간 인덱스는 4입니다 (0부터 시작하는 인덱스 기준).
     - 인덱스 4부터 하향식으로 힙 조정을 합니다.
     - 각 노드에 대해, 그 노드가 자식 노드들보다 크도록 조정합니다. 만약 자식 노드 중 하나가 더 크다면, 그 자식 노드와 위치를 바꿉니다.
     - 이 과정을 루트 노드에 도달할 때까지 반복합니다.